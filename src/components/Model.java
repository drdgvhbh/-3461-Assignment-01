package components;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import components.AnimalTree.AnimalTree;
import components.Data.IterationData;
import components.Data.SessionData;
import components.ImageBox.ImageBoxController;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.property.*;
import javafx.util.Duration;
import javafx.util.Pair;
import util.JSONLogger;

import java.io.IOException;
import java.net.URL;
import java.util.*;
import java.util.List;

/**
 * Represents the state of this application.
 */
public class Model {
    /**
     * The number of iterations in {@link Model.State#PHASE_1} and {@link Model.State#PHASE_2}
     */
    public static int ITERATIONS_PER_PHASE = 10;

    /**
     * The number of <code>milliseconds</code> between each iteration.
     */
    public static int TIME_BETWEEN_ITERATIONS = 250;


    /**
     * The time limit for each iteration.
     */
    public static int ITERATION_TIME_LIMIT = 2000;

    /**
     * Encapsulates the <code>state</code>.
     */
    private SimpleObjectProperty<State> state;

    /**
     * <p>The timer for each iteration.</p>
     *
     * <p>A iteration is when the next set of button images are generated.
     *
     */
    private Timeline timer;

    /**
     * <p>The number of iterations that have occurred.</p>
     *
     * <p>An iteration is when the next set of button images are generated.</p>
     */
    private SimpleIntegerProperty iteration;

    /**
     * <p>The random number generator.</p>
     */
    private Random rnd;

    /**
     * <p>
     *     Represents the current relationship between an {@link components.ImageBox.ImageBoxController} and the
     *     <code>URL</code> of the image it is controlling.
     * </p>
     *
     * <p>The image <code>URL</code>s must be relative to the root directory.</p>
     */
    private Map<ImageBoxControllerId, StringProperty> currentAnimalImages;

    /**
     * The correct animal name for this iteration.
     */
    private SimpleStringProperty correctAnimalName;

    /**
     * <p>
     *     The <code>URL</code> of an image that represents an animal in the same category as
     *     {@link Model#correctAnimalName}.
     * </p>
     *
     * <p>The categorization is defined in a hierarchy generated by {@link AnimalTree}.</p>
     */
    private SimpleStringProperty similarImageURL;

    /**
     * <p>
     *     Represents the current relationship between an {@link components.ImageBox.ImageBoxController} and the
     *     name of the image it is controlling.
     * </p>
     *
     * <p>The name is the most specific name of the animal, rather than the generic one.</p>
     *
     * @see AnimalTree#getGenericName(String, List)
     */
    private Map<ImageBoxControllerId, StringProperty> currentAnimalNames;

    /**
     * Represents a shuffled collection of {@link Model#currentAnimalNames}.
     */
    private SimpleObjectProperty<Map<ImageBoxControllerId, String>> currentScrambledAnimalNames;

    /**
     * Represents the collection of image combination queries for each iteration.
     *
     * @see Model#generateImageCombination(String, boolean)
     */
    private JsonNode imageCombinationsNode;

    /**
     * Represents the current relationship between a {@link components.ProgressBox.ProgressBoxController} and its
     * active state.
     */
    private Map<ProgressBoxId, BooleanProperty> activeProgressBoxes;

    /**
     * Represents data generated and gathered from the current <code>iteration</code>.
     */
    private IterationData currentIterationData;

    /**
     * Represents data generated and gathered from the entire lifespan of this application.
     */
    private SessionData sessionData;

    /**
     * Initializes a new instance of the {@link Model} class.
     */
    public Model() {
        currentIterationData = new IterationData();
        iteration = new SimpleIntegerProperty(0);
        rnd = new Random();
        sessionData = new SessionData();
        activeProgressBoxes = new HashMap<>();
        for (ProgressBoxId id : ProgressBoxId.values()) {
            activeProgressBoxes.put(id, new SimpleBooleanProperty(false));
        }

        this.correctAnimalName = new SimpleStringProperty("");
        this.similarImageURL = new SimpleStringProperty("");
        this.state = new SimpleObjectProperty<>(State.MENU);
        currentAnimalNames = new HashMap<>();
        currentScrambledAnimalNames = new SimpleObjectProperty<>();
        currentScrambledAnimalNames.set(new HashMap<>());
        currentAnimalImages = new HashMap<>();
        JsonParser jsonParser = null;
        URL path = getClass().getResource("/resources/ImageCombinations.json");
        try {
            jsonParser = new JsonFactory().createParser(path);
            jsonParser.setCodec(new ObjectMapper());
            imageCombinationsNode = jsonParser.readValueAsTree();
        } catch (NullPointerException e) {
            JSONLogger.err("File Not Found.", new Pair<>("File", path.toExternalForm()));
        } catch (IOException e) {
            JSONLogger.err("Parsing Error.", new Pair<>("File", path.toExternalForm()));
        }

        generateImageCombination("Blanks", false);
    }

    /**
     * Identification classifiers for {@link ImageBoxController}
     */
    public enum ImageBoxControllerId {
        /**
         * The top left controller.
         */
        TOP_LEFT,

        /**
         * The top right controller.
         */
        TOP_RIGHT,

        /**
         * The bottom left controller.
         */
        BOTTOM_LEFT,

        /**
         * The bottom right controller.
         */
        BOTTOM_RIGHT

    }

    /**
     * Identification classifiers for {@link components.ProgressBox.ProgressBoxController}
     */
    public enum ProgressBoxId {
        /**
         * The first controller.
         */
        ONE,

        /**
         * The second controller.
         */
        TWO,

        /**
         * The third controller.
         */
        THREE,

        /**
         * The fourth controller.
         */
        FOUR,

        /**
         * The fifth controller.
         */
        FIVE,

        /**
         * The sixth controller.
         */
        SIX,

        /**
         * The seventh controller.
         */
        SEVEN,

        /**
         * The eighth controller.
         */
        EIGHT,

        /**
         * The ninth controller.
         */
        NINE,

        /**
         * The tenth controller.
         */
        TEN
    }

    /**
     * The states of this <code>Model</code>.
     */
    public enum State {
        /**
         * Represents the state before the application is started.
         */
        MENU,

        /**
         * Represents the state where each <code>iteration</code> does not have a label associated with it.
         */
        PHASE_1,

        /**
         * Represents the state where each <code>iteration</code> does have a label associated with it.
         */
        PHASE_2,

        /**
         * Represents the state where the application is paused.
         */
        PAUSED
    }

    /**
     * Gets the state of this <code>Model</code>.
     *
     * @return the state of this <code>Model</code>
     */
    public Model.State getState() {
        return state.get();
    }

    /**
     * Gets the {@link Model#state} property.
     *
     * @return the {@link Model#state} property
     */
    public SimpleObjectProperty<Model.State> stateProperty() {
        return state;
    }

    /**
     * Sets the state of this <code>Model</code>.
     *
     *
     * @param state The new <code>state</code> of this <code>Model</code>.
     */
    public void setState(Model.State state) {
        this.state.set(state);
    }

    /**
     * Gets the timer.
     * @return the <code>timer</code>
     */
    public Timeline getTimer() {
        return timer;
    }

    /**
     * Sets the timer.
     * @param timer the new timer
     */
    public void setTimer(Timeline timer) {
        this.timer = timer;
    }

    /**
     * <p>Gets the current number of iterations.</p>
     *
     * <p>An iteration is when the next set of button images are generated.</p>
     *
     * @return the current number of display iterations
     */
    public int getIteration() {
        return this.iteration.get();
    }

    /**
     * Gets the {@link Model#iteration} property.
     *
     * @return the {@link Model#iteration} property
     */
    public SimpleIntegerProperty iterationProperty() {
        return iteration;
    }

    /**
     * Increases the number of <code>iterations</code> by 1.
     *
     */
    public void increaseIteration() {
        this.iteration.set(this.iteration.get() + 1);
    }

    /**
     * Gets the random number generator.
     * @return the random number generator.
     */
    public Random getRandom() {
        return rnd;
    }

    /**
     * Resets the number of <code>iterations</code> to 0.
     */
    public void resetIterations() {
        this.iteration.set(0);
    }

    /**
     * <p>
     *     Gets the collection that represents the current relationship between an
     *     {@link components.ImageBox.ImageBoxController} and the <code>URL</code> of the image it is controlling.
     * </p>
     *
     * @return an unmodifiable collection of the {@link Model#currentAnimalImages} if {@link Model#currentAnimalImages}
     * is not <code>null</code>; otherwise, <code>null</code>
     */
    public Map<ImageBoxControllerId, StringProperty> getCurrentAnimalImages() {
        try {
            return Collections.unmodifiableMap(currentAnimalImages);
        } catch (NullPointerException e) {
            JSONLogger.err("Animal combinations not initialized.");
        }
        return null;
    }

    /**
     * Gets the name that represents the correct animal name for this iteration.
     *
     * @return the correct animal name for this iteration.
     */
    public String getCorrectAnimalName() {
        return correctAnimalName.get();
    }

    /**
     * Gets the {@link Model#correctAnimalName} property.
     *
     * @return the {@link Model#correctAnimalName} property
     */
    public SimpleStringProperty correctAnimalNameProperty() {
        return correctAnimalName;
    }

    /**
     * Sets the {@link Model#correctAnimalName}.
     *
     * @param correctAnimalName The correct animal name for this iteration.
     */
    public void setCorrectAnimalName(String correctAnimalName) {
        this.correctAnimalName.set(correctAnimalName);
    }

    /**
     * <p>
     *     Gets the <code>URL</code> of an image that represents an animal in the same category as
     *     {@link Model#correctAnimalName}.
     * </p>
     *
     * <p>The categorization is defined in a hierarchy generated by {@link AnimalTree}.</p>
     * @return the <code>URL</code> of an image
     */
    public String getSimilarImageURL() {
        return similarImageURL.get();
    }

    /**
     * Gets the {@link Model#similarImageURL} property.
     *
     * @return the {@link Model#similarImageURL} property.
     */
    public SimpleStringProperty similarImageURLProperty() {
        return similarImageURL;
    }

    /**
     * <p>Sets the {@link Model#similarImageURL}.</p>
     *
     * <p>The <code>URL</code> must be relative to the root directory.</p>
     *
     * @param similarImageURL the <code>URL</code> of an image that represents an animal in the same category
     *                        as {@link Model#correctAnimalName}
     */
    public void setSimilarImageURL(String similarImageURL) {
        this.similarImageURL.set(similarImageURL);
    }

    /**
     * <p>
     *     Gets the current relationship between an {@link components.ImageBox.ImageBoxController} and the
     *     name of the image it is controlling.
     * </p>
     *
     * <p>The name is the most specific name of the animal, rather than the generic one.</p>
     *
     * @see AnimalTree#getGenericName(String, List)
     * @return an unmodifiable collection of the {@link Model#currentAnimalNames} if {@link Model#currentAnimalNames}
     * is not <code>null</code>; otherwise, <code>null</code>
     */
    public Map<ImageBoxControllerId, StringProperty> getCurrentAnimalNames() {
        try {
            return Collections.unmodifiableMap(currentAnimalNames);
        } catch (NullPointerException e) {
            JSONLogger.err("Animal combinations not initialized.");
        }
        return null;
    }

    /**
     * Gets a shuffled collection of {@link Model#currentAnimalNames}.
     * @return the {@link Model#currentScrambledAnimalNames}
     */
    public Map<ImageBoxControllerId, String> getCurrentScrambledAnimalNames() {
        return currentScrambledAnimalNames.get();
    }

    /**
     * Gets the {@link Model#currentScrambledAnimalNames} property.
     * @return the {@link Model#currentScrambledAnimalNames} property
     */
    public SimpleObjectProperty<Map<ImageBoxControllerId, String>> currentScrambledAnimalNamesProperty() {
        return currentScrambledAnimalNames;
    }

    /**
     * Sets the {@link Model#currentScrambledAnimalNames}.
     * @param currentScrambledAnimalNames the scrambled animal names
     */
    public void setCurrentScrambledAnimalNames(Map<ImageBoxControllerId, String> currentScrambledAnimalNames) {
        this.currentScrambledAnimalNames.set(currentScrambledAnimalNames);
    }

    /**
     * Gets the current relationship between a {@link components.ProgressBox.ProgressBoxController} and its
     * active state.
     *
     * @return the {@link Model#activeProgressBoxes}
     */
    public Map<ProgressBoxId, BooleanProperty> getActiveProgressBoxes() {
        return this.activeProgressBoxes;
    }

    /**
     * Gets the data generated and gathered from the current <code>iteration</code>.
     *
     * @return the data generated and gathered from the current <code>iteration</code>
     */
    public IterationData getCurrentIterationData() {
        return currentIterationData;
    }

    /**
     * Sets the {@link Model#currentIterationData}.
     * @param currentIterationData the current iteration data
     */
    public void setCurrentIterationData (IterationData currentIterationData) {
        this.currentIterationData = currentIterationData;
    }

    /**
     * Gets the data generated and gathered from the entire lifespan of this application.
     *
     * @return the data generated and gathered from the entire lifespan of this application.
     */
    public SessionData getSessionData() {
        return this.sessionData;
    }

    /////////////////////////////////////////////////
    private AnimalTree animalTree;

    public AnimalTree getAnimalTree() {
        return this.animalTree;
    }

    /**
     * Resets this <code>Model</code> to only contain placeholder button images.
     *
     * <p>{@link Model#currentAnimalImages} and {@link Model#similarImageURL} are filled with placeholder images.</p>
     */
    public void resetAnimalImages() {
        generateImageCombination("Blanks", false);
        similarImageURL.set(getClass().getResource("/resources/images/blank_button.jpg").toExternalForm());
    }

    /**
     * Resets this <code>Model</code> to have empty strings for animal names.
     *
     * <p>
     *     {@link Model#currentScrambledAnimalNames}, {@link Model#currentAnimalNames}, and
     *     {@link Model#correctAnimalName} are filled with empty strings.
     * </p>
     */
    public void resetAnimalNames() {
        correctAnimalName.set("");

        Map<Model.ImageBoxControllerId, String> blankMap = new HashMap<>(getCurrentScrambledAnimalNames());
        blankMap.replaceAll((k, v) -> "");
        currentScrambledAnimalNames.set(blankMap);

        for (StringProperty s : currentAnimalNames.values()) {
            s.set("");
        }
    }

    public void buildAnimalTree() {
        URL path = getClass().getResource("/resources/AnimalTree.json");
        ;
        try {
            animalTree = new AnimalTree();

            JsonParser jsonParser = new JsonFactory().createParser(path);
            jsonParser.setCodec(new ObjectMapper());
            JsonNode jsonNode = jsonParser.readValueAsTree();

            Queue<JsonNode> animalQueue = new LinkedList<>();
            animalQueue.add(jsonNode);

            Queue<String> parentQueue = new LinkedList<>() {{
                add(null);
            }};
            while (!animalQueue.isEmpty()) {
                JsonNode node = animalQueue.remove();
                Iterator<Map.Entry<String, JsonNode>> it = node.fields();
                while (it.hasNext()) {
                    Map.Entry<String, JsonNode> entry = it.next();
                    if (entry.getValue().isObject()) {
                        animalTree.addAnimal(entry.getKey(), null, parentQueue.poll());
                        for (int i = 0; i < entry.getValue().size(); i++) {
                            parentQueue.add(entry.getKey());
                        }
                        animalQueue.add(entry.getValue());
                    } else {
                        List<URL> urls = new ArrayList<>();
                         if (entry.getValue().isArray()) {
                             for (final JsonNode url : entry.getValue()) {
                                 urls.add(getClass().getResource(
                                     url.toString().replace("\"", "")));
                             }
                         } else {
                             urls.add(getClass().getResource(
                                 entry.getValue().toString().replace("\"", "")));
                         }
                        animalTree.addAnimal(
                            entry.getKey(),
                            urls,
                            parentQueue.poll()
                        );

                    }

                }

            }
        } catch (NullPointerException e) {
            JSONLogger.err("File Not Found.", new Pair<>("File", path.toExternalForm()));
        } catch (IOException e) {
            JSONLogger.err("Parsing Error.", new Pair<>("File", path.toExternalForm()));
        }


    }

    public void generateImageCombination(String iteration) {
        generateImageCombination(iteration, true);
    }

    private void generateImageCombination(String query, boolean delete) {
        buildAnimalTree();
        int i = 0;
        String currentQuery = "";
        try {
            for (ImageBoxControllerId id : ImageBoxControllerId.values()) {
                if (query.equals("Blanks")) {
                    if (currentAnimalImages.get(id) == null) {
                        currentAnimalImages.put(id,
                            new SimpleStringProperty(getClass().getResource(
                                "/resources/images/blank_button.jpg").toExternalForm()));
                    } else {
                        currentAnimalImages.get(id).set(getClass().getResource(
                            "/resources/images/blank_button.jpg").toExternalForm());
                    }
                } else {
                    currentQuery = imageCombinationsNode.get(
                        String.valueOf(query)).get(i).toString().replace("\"", "");

                    // Set current iterations combination query;
                    List<String> combinations = new ArrayList<>();
                    for (JsonNode s : imageCombinationsNode.get(String.valueOf(query))) {
                        combinations.add(s.toString().replace("\"", ""));
                    }
                    if (currentIterationData != null) {
                        currentIterationData.setAnimalCombinationQuery(combinations);
                    }
                    if (currentAnimalImages.get(id) == null) {
                        currentAnimalImages.put(
                            id,
                            new SimpleStringProperty(animalTree.getAnimalImages(currentQuery).get(0).toExternalForm()));
                    } else {
                        currentAnimalImages.get(id).set(animalTree.getAnimalImages(currentQuery).get(0).toExternalForm());
                    }
                    if (currentAnimalNames.get(id) == null) {
                        currentAnimalNames.put(id, new SimpleStringProperty(animalTree.getLastQueriedAnimal()));
                    } else {
                        currentAnimalNames.get(id).set(animalTree.getLastQueriedAnimal());
                    }
                    String response = animalTree.getLastQueriedAnimal();
                    if (delete) {
                        animalTree.removeAnimal(response);
                    }
                }
                i++;
            }
            buildAnimalTree();
            Map<ImageBoxControllerId, String> scrambledNames = new HashMap<>();
            List<StringProperty> names = new ArrayList<>(currentAnimalNames.values());
            Collections.shuffle(names);
            final Iterator<StringProperty> it = names.iterator();
            for (ImageBoxControllerId id : currentAnimalNames.keySet()) {
                scrambledNames.put(id, animalTree.getGenericName(it.next().get(),
                    new ArrayList<>(currentAnimalNames.values())));
            }
            currentScrambledAnimalNames.set(scrambledNames);
            List<String> animalCombination = new ArrayList<>();
            for (StringProperty s : currentAnimalNames.values()) {
                animalCombination.add(s.get());
            }
            if (currentIterationData != null) {
                currentIterationData.setAnimalCombination(animalCombination);
            }
        } catch (NullPointerException e) {
            JSONLogger.warn("Querying animal images that don't exist.", new Pair<>("Query", currentQuery));
        }
    }


}
